#! /usr/bin/env ruby


###############################################################
# Author: Sishuo Wang from Haiwei Luo Lab at Chinese University of Hong Kong
# E-mail: sishuowang@hotmail.ca sishuowang@cuhk.edu.hk
# Last updated: 2019-08-05
# Copyright: CC 4.0 (https://creativecommons.org/licenses/by/4.0/)
# To see the usage, run generateAlnFromOrthoFinder.rb


######################################################
dir = File.dirname($0)
$: << File.join(dir, 'lib')


###############################################################
require 'getoptlong'
require 'bio'
require 'parallel'
require 'sqlite3'

require 'chang_yong'
require 'Dir'
require 'seqIO'
require 'util'
require 'readOrthogroup'


###############################################################
#out2in_files = ["~/project/Rhizobiales/data/genome_source/out2in.tbl", "~/project/Rhizobiales/data/genome_source/out2in-outgroup.tbl", "~/project/Flavo/data/genome_source/out2in.tbl", "~/project/Flavo/data/genome_source/in2out.tbl", "~/project/Rhizobiales/data/genome_source/out2in-Cyano.tbl"].map{|i|File.expand_path(i)}


###############################################################
$in2out = Hash.new

seq_indirs = Array.new
orthogroupFile = nil
outdir = nil
suffix = 'protein'
cpu = 10
db_file = nil
include_list_file = nil
is_create_db = false
is_force = false
is_tolerate = false
countMinMax = {
  :total  =>  [],
  :perTaxon  =>  [],
}
is_count_ortholog = false
is_print_taxon = false


seq_files = Array.new
species_included = Hash.new


###############################################################
def pf(arr)
  printf("%-30s%-80s\n", arr[0], arr[1])
end


def usage()
  pf(['--seq_dir|seq_indir', "indir of seqs"])
  pf(['--orthogroup', "Orthogroups.tsv generated by OrthoFinder"])
  pf(['--outdir', "outdir"])
  pf(['--suffix', "suffix of seqs"])
  pf(['--count_min_max_total', "min and max counts of the total genes in a family"])
  pf(['--count_min_max_per_taxon', "min and max counts of the total genes in a species/genome"])
  pf(['--count_ortholog', "to search for single-copy genes"])
  pf(['--cpu', "No. of processes"])
  pf(['--db', "DISABLED"])
  pf(['--create_db', "DISABLED"])
  pf(['--include_list', "the list of species/genomes included"])
  pf(['--print_taxon', "delete the species name in the output fasta"])
  pf(['--force', "remove outdir if it exists"])
  pf(['--tolerate', "keep outdir if it exists"])
  pf(['-h', 'print this message'])
  exit 1
end


def getCountMinMax(countMinMax, species_included)
  countMinMax[:total] = species_included.size, species_included.size
  countMinMax[:perTaxon] = 1,1
  return(countMinMax)
end


def outputSeq(outdir, orthogroup_info, seq_objs, countMinMax, species_included, is_print_taxon)
  orthogroup_info.each_pair do |orthogroup, v|
    if species_included.empty?
      total_size = v.values.map{|genes|genes.size}.reduce(:+)
    else
      next if v.select{|taxon, v2|species_included.include?(taxon)}.size == 0
      v = v.select{|taxon, v2|species_included.include?(taxon)}
      total_size = v.values.map{|genes|genes.size}.reduce(:+)
      #total_size = v.select{|taxon, v2|species_included.include?(taxon)}.values.map{|genes|genes.size}.reduce(:+)
    end

    next if total_size < countMinMax[:total][0] or total_size > countMinMax[:total][1] if not countMinMax[:total].empty?
    next if v.values.any?{|i|i.size<countMinMax[:perTaxon][0] or i.size>countMinMax[:perTaxon][1]} if not countMinMax[:perTaxon].empty?

    outfile = File.join(outdir, orthogroup + '.fas')
    out_fh = File.open(outfile, 'w')
    v.each_pair do |species, genes|
      genes.each do |gene|
        next if not seq_objs.include?(species)
        out_fh.puts '>' + (is_print_taxon ? species : gene)
        out_fh.puts seq_objs[species][gene].seq
      end
    end
    out_fh.close
  end
end


def createDb(db_file, seq_objs)
  db = SQLite3::Database.new(db_file)

  result = db.execute <<-SQL
    DROP TABLE IF EXISTS seqInfo;
  SQL
  result = db.execute <<-SQL
    CREATE TABLE seqInfo(
      taxon VARCHAR(50),
      title VARCHAR(75),
      seq VARCHAR(5000)
    );
  SQL

  seq_objs.each_pair do |taxon, v|
    puts taxon
    v.each_pair do |title, f|
      values_str = [taxon, title, f.seq.to_s].map{|i|addQuotes(i)}.join(',')
      query = "INSERT INTO seqInfo(taxon,title,seq) VALUES(#{values_str});"
      db.execute(query)
    end
  end
end


def addQuotes(i)
  if i.class == String
    i = ['"', '"'].join(i)
  end
  return(i)
end


###############################################################
usage if ARGV.empty?

opts = GetoptLong.new(
  ['--seq_dir', '--seq_indir', GetoptLong::REQUIRED_ARGUMENT],
  ['--orthogroup', GetoptLong::REQUIRED_ARGUMENT],
  ['--outdir', GetoptLong::REQUIRED_ARGUMENT],
  ['--suffix', GetoptLong::REQUIRED_ARGUMENT],
  ['--count_min_max_total', GetoptLong::REQUIRED_ARGUMENT],
  ['--count_min_max_per_taxon', GetoptLong::REQUIRED_ARGUMENT],
  ['--count_ortholog', GetoptLong::NO_ARGUMENT],
  ['--cpu', GetoptLong::REQUIRED_ARGUMENT],
  ['--db', GetoptLong::REQUIRED_ARGUMENT],
  ['--create_db', GetoptLong::NO_ARGUMENT],
  ['--include_list', GetoptLong::REQUIRED_ARGUMENT],
  ['--print_taxon', GetoptLong::NO_ARGUMENT],
  ['--force', GetoptLong::NO_ARGUMENT],
  ['--tolerate', GetoptLong::NO_ARGUMENT],
  ['-h', GetoptLong::NO_ARGUMENT],
)


opts.each do |opt, value|
  case opt
    when /^--(seq_indir|seq_dir)$/
      seq_indirs << value.split(',')
    when /^--orthogroup$/
      orthogroupFile = File.expand_path(value)
    when /^--outdir$/
      outdir = value
    when /^--suffix$/
      suffix = value
    when /^--count_min_max_total$/
      countMinMax[:total] = value.split(',').map{|i|i.to_i}
    when /^--count_min_max_per_taxon$/
      countMinMax[:perTaxon] = value.split(',').map{|i|i.to_i}
    when /^--count_ortholog$/
      is_count_ortholog = true
    when /^--cpu$/
      cpu = value.to_i
    when /^--db$/
      db_file = value
    when /^--create_db$/
      is_create_db = true
    when /^--include_list$/
      include_list_file = value
    when /^--print_taxon$/
      is_print_taxon = true
    when /^--force$/
      is_force = true
    when /^--tolerate$/
      is_tolerate = true
    when /^-h$/
      usage()
  end
end


seq_indirs.flatten!



###############################################################
###############################################################
if __FILE__ == $0
  mkdir_with_force(outdir, is_force, is_tolerate)

  species_included = read_list(include_list_file) if not include_list_file.nil?

  if is_count_ortholog
    if not species_included.empty?
      countMinMax = getCountMinMax(countMinMax, species_included)
    else
      STDERR.puts "Wrong! species list must be provided to use --count_ortholog"
      exit 1
    end
  end

  #############################################################
  #$out2in, $in2out = getSpeciesNameRela(out2in_files)

  seq_indirs.each do |seq_indir|
    seq_files << read_infiles(seq_indir, suffix)
  end
  seq_files.flatten!

  prot2taxon = getProt2Taxon(seq_files, cpu)
  seq_objs = read_seq_from_dir(seq_files, suffix, species_included, cpu, $in2out, prot2taxon)
  raise "seq_files empty. suffix wrong?" if seq_objs.empty?
  
  if is_create_db
    createDb(db_file, seq_objs); exit 0
  end

  orthogroup_info = readOrthogroupFile(orthogroupFile)

  outputSeq(outdir, orthogroup_info, seq_objs, countMinMax, species_included, is_print_taxon)
end


